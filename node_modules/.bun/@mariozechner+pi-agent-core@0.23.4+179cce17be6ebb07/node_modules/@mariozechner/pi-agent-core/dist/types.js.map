{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import type {\n\tAgentTool,\n\tAssistantMessage,\n\tAssistantMessageEvent,\n\tMessage,\n\tModel,\n\tToolResultMessage,\n\tUserMessage,\n} from \"@mariozechner/pi-ai\";\n\n/**\n * Attachment type definition.\n * Processing is done by consumers (e.g., document extraction in web-ui).\n */\nexport interface Attachment {\n\tid: string;\n\ttype: \"image\" | \"document\";\n\tfileName: string;\n\tmimeType: string;\n\tsize: number;\n\tcontent: string; // base64 encoded (without data URL prefix)\n\textractedText?: string; // For documents\n\tpreview?: string; // base64 image preview\n}\n\n/**\n * Thinking/reasoning level for models that support it.\n * Note: \"xhigh\" is only supported by OpenAI codex-max models.\n */\nexport type ThinkingLevel = \"off\" | \"minimal\" | \"low\" | \"medium\" | \"high\" | \"xhigh\";\n\n/**\n * User message with optional attachments.\n */\nexport type UserMessageWithAttachments = UserMessage & { attachments?: Attachment[] };\n\n/**\n * Extensible interface for custom app messages.\n * Apps can extend via declaration merging:\n *\n * @example\n * ```typescript\n * declare module \"@mariozechner/agent\" {\n *   interface CustomMessages {\n *     artifact: ArtifactMessage;\n *     notification: NotificationMessage;\n *   }\n * }\n * ```\n */\nexport interface CustomMessages {\n\t// Empty by default - apps extend via declaration merging\n}\n\n/**\n * AppMessage: Union of LLM messages + attachments + custom messages.\n * This abstraction allows apps to add custom message types while maintaining\n * type safety and compatibility with the base LLM messages.\n */\nexport type AppMessage =\n\t| AssistantMessage\n\t| UserMessageWithAttachments\n\t| Message // Includes ToolResultMessage\n\t| CustomMessages[keyof CustomMessages];\n\n/**\n * Agent state containing all configuration and conversation data.\n */\nexport interface AgentState {\n\tsystemPrompt: string;\n\tmodel: Model<any>;\n\tthinkingLevel: ThinkingLevel;\n\ttools: AgentTool<any>[];\n\tmessages: AppMessage[]; // Can include attachments + custom message types\n\tisStreaming: boolean;\n\tstreamMessage: Message | null;\n\tpendingToolCalls: Set<string>;\n\terror?: string;\n}\n\n/**\n * Events emitted by the Agent for UI updates.\n * These events provide fine-grained lifecycle information for messages, turns, and tool executions.\n */\nexport type AgentEvent =\n\t// Agent lifecycle\n\t| { type: \"agent_start\" }\n\t| { type: \"agent_end\"; messages: AppMessage[] }\n\t// Turn lifecycle - a turn is one assistant response + any tool calls/results\n\t| { type: \"turn_start\" }\n\t| { type: \"turn_end\"; message: AppMessage; toolResults: ToolResultMessage[] }\n\t// Message lifecycle - emitted for user, assistant, and toolResult messages\n\t| { type: \"message_start\"; message: AppMessage }\n\t// Only emitted for assistant messages during streaming\n\t| { type: \"message_update\"; message: AppMessage; assistantMessageEvent: AssistantMessageEvent }\n\t| { type: \"message_end\"; message: AppMessage }\n\t// Tool execution lifecycle\n\t| { type: \"tool_execution_start\"; toolCallId: string; toolName: string; args: any }\n\t| { type: \"tool_execution_update\"; toolCallId: string; toolName: string; args: any; partialResult: any }\n\t| { type: \"tool_execution_end\"; toolCallId: string; toolName: string; result: any; isError: boolean };\n"]}