import { ThinkingLevel } from "@google/genai";
import { streamAnthropic } from "./providers/anthropic.js";
import { streamGoogle } from "./providers/google.js";
import { streamOpenAICompletions } from "./providers/openai-completions.js";
import { streamOpenAIResponses } from "./providers/openai-responses.js";
const apiKeys = new Map();
export function setApiKey(provider, key) {
    apiKeys.set(provider, key);
}
export function getApiKey(provider) {
    // Check explicit keys first
    const key = apiKeys.get(provider);
    if (key)
        return key;
    // Fall back to environment variables
    if (provider === "github-copilot") {
        return process.env.COPILOT_GITHUB_TOKEN || process.env.GH_TOKEN || process.env.GITHUB_TOKEN;
    }
    const envMap = {
        openai: "OPENAI_API_KEY",
        anthropic: "ANTHROPIC_API_KEY",
        google: "GEMINI_API_KEY",
        groq: "GROQ_API_KEY",
        cerebras: "CEREBRAS_API_KEY",
        xai: "XAI_API_KEY",
        openrouter: "OPENROUTER_API_KEY",
        zai: "ZAI_API_KEY",
        mistral: "MISTRAL_API_KEY",
    };
    const envVar = envMap[provider];
    return envVar ? process.env[envVar] : undefined;
}
export function stream(model, context, options) {
    const apiKey = options?.apiKey || getApiKey(model.provider);
    if (!apiKey) {
        throw new Error(`No API key for provider: ${model.provider}`);
    }
    const providerOptions = { ...options, apiKey };
    const api = model.api;
    switch (api) {
        case "anthropic-messages":
            return streamAnthropic(model, context, providerOptions);
        case "openai-completions":
            return streamOpenAICompletions(model, context, providerOptions);
        case "openai-responses":
            return streamOpenAIResponses(model, context, providerOptions);
        case "google-generative-ai":
            return streamGoogle(model, context, providerOptions);
        default: {
            // This should never be reached if all Api cases are handled
            const _exhaustive = api;
            throw new Error(`Unhandled API: ${_exhaustive}`);
        }
    }
}
export async function complete(model, context, options) {
    const s = stream(model, context, options);
    return s.result();
}
export function streamSimple(model, context, options) {
    const apiKey = options?.apiKey || getApiKey(model.provider);
    if (!apiKey) {
        throw new Error(`No API key for provider: ${model.provider}`);
    }
    const providerOptions = mapOptionsForApi(model, options, apiKey);
    return stream(model, context, providerOptions);
}
export async function completeSimple(model, context, options) {
    const s = streamSimple(model, context, options);
    return s.result();
}
function mapOptionsForApi(model, options, apiKey) {
    const base = {
        temperature: options?.temperature,
        maxTokens: options?.maxTokens || Math.min(model.maxTokens, 32000),
        signal: options?.signal,
        apiKey: apiKey || options?.apiKey,
    };
    // Helper to clamp xhigh to high for providers that don't support it
    const clampReasoning = (effort) => (effort === "xhigh" ? "high" : effort);
    switch (model.api) {
        case "anthropic-messages": {
            // Explicitly disable thinking when reasoning is not specified
            if (!options?.reasoning) {
                return { ...base, thinkingEnabled: false };
            }
            const anthropicBudgets = {
                minimal: 1024,
                low: 2048,
                medium: 8192,
                high: 16384,
            };
            return {
                ...base,
                thinkingEnabled: true,
                thinkingBudgetTokens: anthropicBudgets[clampReasoning(options.reasoning)],
            };
        }
        case "openai-completions":
            return {
                ...base,
                reasoningEffort: options?.reasoning,
            };
        case "openai-responses":
            return {
                ...base,
                reasoningEffort: options?.reasoning,
            };
        case "google-generative-ai": {
            // Explicitly disable thinking when reasoning is not specified
            // This is needed because Gemini has "dynamic thinking" enabled by default
            if (!options?.reasoning) {
                return { ...base, thinking: { enabled: false } };
            }
            const googleModel = model;
            const effort = clampReasoning(options.reasoning);
            // Gemini 3 models use thinkingLevel exclusively instead of thinkingBudget.
            // https://ai.google.dev/gemini-api/docs/thinking#set-budget
            if (isGemini3ProModel(googleModel) || isGemini3FlashModel(googleModel)) {
                return {
                    ...base,
                    thinking: {
                        enabled: true,
                        level: getGemini3ThinkingLevel(effort, googleModel),
                    },
                };
            }
            return {
                ...base,
                thinking: {
                    enabled: true,
                    budgetTokens: getGoogleBudget(googleModel, effort),
                },
            };
        }
        default: {
            // Exhaustiveness check
            const _exhaustive = model.api;
            throw new Error(`Unhandled API in mapOptionsForApi: ${_exhaustive}`);
        }
    }
}
function isGemini3ProModel(model) {
    // Covers gemini-3-pro, gemini-3-pro-preview, and possible other prefixed ids in the future
    return model.id.includes("3-pro");
}
function isGemini3FlashModel(model) {
    // Covers gemini-3-flash, gemini-3-flash-preview, and possible other prefixed ids in the future
    return model.id.includes("3-flash");
}
function getGemini3ThinkingLevel(effort, model) {
    if (isGemini3ProModel(model)) {
        // Gemini 3 Pro only supports LOW/HIGH (for now)
        switch (effort) {
            case "minimal":
            case "low":
                return ThinkingLevel.LOW;
            case "medium":
            case "high":
                return ThinkingLevel.HIGH;
        }
    }
    // Gemini 3 Flash supports all four levels
    switch (effort) {
        case "minimal":
            return ThinkingLevel.MINIMAL;
        case "low":
            return ThinkingLevel.LOW;
        case "medium":
            return ThinkingLevel.MEDIUM;
        case "high":
            return ThinkingLevel.HIGH;
    }
}
function getGoogleBudget(model, effort) {
    // See https://ai.google.dev/gemini-api/docs/thinking#set-budget
    if (model.id.includes("2.5-pro")) {
        const budgets = {
            minimal: 128,
            low: 2048,
            medium: 8192,
            high: 32768,
        };
        return budgets[effort];
    }
    if (model.id.includes("2.5-flash")) {
        // Covers 2.5-flash-lite as well
        const budgets = {
            minimal: 128,
            low: 2048,
            medium: 8192,
            high: 24576,
        };
        return budgets[effort];
    }
    // Unknown model - use dynamic
    return -1;
}
//# sourceMappingURL=stream.js.map