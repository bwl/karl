import { streamAnthropic } from "./providers/anthropic.js";
import { streamGoogle } from "./providers/google.js";
import { streamOpenAICompletions } from "./providers/openai-completions.js";
import { streamOpenAIResponses } from "./providers/openai-responses.js";
const apiKeys = new Map();
export function setApiKey(provider, key) {
    apiKeys.set(provider, key);
}
export function getApiKey(provider) {
    // Check explicit keys first
    const key = apiKeys.get(provider);
    if (key)
        return key;
    // Fall back to environment variables
    const envMap = {
        openai: "OPENAI_API_KEY",
        anthropic: "ANTHROPIC_API_KEY",
        google: "GEMINI_API_KEY",
        groq: "GROQ_API_KEY",
        cerebras: "CEREBRAS_API_KEY",
        xai: "XAI_API_KEY",
        openrouter: "OPENROUTER_API_KEY",
        zai: "ZAI_API_KEY",
    };
    const envVar = envMap[provider];
    return envVar ? process.env[envVar] : undefined;
}
export function stream(model, context, options) {
    const apiKey = options?.apiKey || getApiKey(model.provider);
    if (!apiKey) {
        throw new Error(`No API key for provider: ${model.provider}`);
    }
    const providerOptions = { ...options, apiKey };
    const api = model.api;
    switch (api) {
        case "anthropic-messages":
            return streamAnthropic(model, context, providerOptions);
        case "openai-completions":
            return streamOpenAICompletions(model, context, providerOptions);
        case "openai-responses":
            return streamOpenAIResponses(model, context, providerOptions);
        case "google-generative-ai":
            return streamGoogle(model, context, providerOptions);
        default: {
            // This should never be reached if all Api cases are handled
            const _exhaustive = api;
            throw new Error(`Unhandled API: ${_exhaustive}`);
        }
    }
}
export async function complete(model, context, options) {
    const s = stream(model, context, options);
    return s.result();
}
export function streamSimple(model, context, options) {
    const apiKey = options?.apiKey || getApiKey(model.provider);
    if (!apiKey) {
        throw new Error(`No API key for provider: ${model.provider}`);
    }
    const providerOptions = mapOptionsForApi(model, options, apiKey);
    return stream(model, context, providerOptions);
}
export async function completeSimple(model, context, options) {
    const s = streamSimple(model, context, options);
    return s.result();
}
function mapOptionsForApi(model, options, apiKey) {
    const base = {
        temperature: options?.temperature,
        maxTokens: options?.maxTokens || Math.min(model.maxTokens, 32000),
        signal: options?.signal,
        apiKey: apiKey || options?.apiKey,
    };
    switch (model.api) {
        case "anthropic-messages": {
            if (!options?.reasoning)
                return base;
            const anthropicBudgets = {
                minimal: 1024,
                low: 2048,
                medium: 8192,
                high: 16384,
            };
            return {
                ...base,
                thinkingEnabled: true,
                thinkingBudgetTokens: anthropicBudgets[options.reasoning],
            };
        }
        case "openai-completions":
            return {
                ...base,
                reasoningEffort: options?.reasoning,
            };
        case "openai-responses":
            return {
                ...base,
                reasoningEffort: options?.reasoning,
            };
        case "google-generative-ai": {
            if (!options?.reasoning)
                return base;
            const googleBudget = getGoogleBudget(model, options.reasoning);
            return {
                ...base,
                thinking: {
                    enabled: true,
                    budgetTokens: googleBudget,
                },
            };
        }
        default: {
            // Exhaustiveness check
            const _exhaustive = model.api;
            throw new Error(`Unhandled API in mapOptionsForApi: ${_exhaustive}`);
        }
    }
}
function getGoogleBudget(model, effort) {
    // See https://ai.google.dev/gemini-api/docs/thinking#set-budget
    if (model.id.includes("2.5-pro")) {
        const budgets = {
            minimal: 128,
            low: 2048,
            medium: 8192,
            high: 32768,
        };
        return budgets[effort];
    }
    if (model.id.includes("2.5-flash")) {
        // Covers 2.5-flash-lite as well
        const budgets = {
            minimal: 128,
            low: 2048,
            medium: 8192,
            high: 24576,
        };
        return budgets[effort];
    }
    // Unknown model - use dynamic
    return -1;
}
//# sourceMappingURL=stream.js.map