{"version":3,"file":"transorm-messages.d.ts","sourceRoot":"","sources":["../../src/providers/transorm-messages.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,GAAG,EAAoB,OAAO,EAAE,KAAK,EAAE,MAAM,aAAa,CAAC;AAEzE,wBAAgB,iBAAiB,CAAC,IAAI,SAAS,GAAG,EAAE,QAAQ,EAAE,OAAO,EAAE,EAAE,KAAK,EAAE,KAAK,CAAC,IAAI,CAAC,GAAG,OAAO,EAAE,CA2FtG","sourcesContent":["import type { Api, AssistantMessage, Message, Model } from \"../types.js\";\n\nexport function transformMessages<TApi extends Api>(messages: Message[], model: Model<TApi>): Message[] {\n\treturn messages\n\t\t.map((msg) => {\n\t\t\t// User and toolResult messages pass through unchanged\n\t\t\tif (msg.role === \"user\" || msg.role === \"toolResult\") {\n\t\t\t\treturn msg;\n\t\t\t}\n\n\t\t\t// Assistant messages need transformation check\n\t\t\tif (msg.role === \"assistant\") {\n\t\t\t\tconst assistantMsg = msg as AssistantMessage;\n\n\t\t\t\t// If message is from the same provider and API, keep as is\n\t\t\t\tif (assistantMsg.provider === model.provider && assistantMsg.api === model.api) {\n\t\t\t\t\treturn msg;\n\t\t\t\t}\n\n\t\t\t\t// Transform message from different provider/model\n\t\t\t\tconst transformedContent = assistantMsg.content.map((block) => {\n\t\t\t\t\tif (block.type === \"thinking\") {\n\t\t\t\t\t\t// Convert thinking block to text block with <thinking> tags\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: \"text\" as const,\n\t\t\t\t\t\t\ttext: `<thinking>\\n${block.thinking}\\n</thinking>`,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\t// All other blocks (text, toolCall) pass through unchanged\n\t\t\t\t\treturn block;\n\t\t\t\t});\n\n\t\t\t\t// Return transformed assistant message\n\t\t\t\treturn {\n\t\t\t\t\t...assistantMsg,\n\t\t\t\t\tcontent: transformedContent,\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn msg;\n\t\t})\n\t\t.map((msg, index, allMessages) => {\n\t\t\t// Second pass: filter out tool calls without corresponding tool results\n\t\t\tif (msg.role !== \"assistant\") {\n\t\t\t\treturn msg;\n\t\t\t}\n\n\t\t\tconst assistantMsg = msg as AssistantMessage;\n\t\t\tconst isLastMessage = index === allMessages.length - 1;\n\n\t\t\t// If this is the last message, keep all tool calls (ongoing turn)\n\t\t\tif (isLastMessage) {\n\t\t\t\treturn msg;\n\t\t\t}\n\n\t\t\t// Extract tool call IDs from this message\n\t\t\tconst toolCallIds = assistantMsg.content\n\t\t\t\t.filter((block) => block.type === \"toolCall\")\n\t\t\t\t.map((block) => (block.type === \"toolCall\" ? block.id : \"\"));\n\n\t\t\t// If no tool calls, return as is\n\t\t\tif (toolCallIds.length === 0) {\n\t\t\t\treturn msg;\n\t\t\t}\n\n\t\t\t// Scan forward through subsequent messages to find matching tool results\n\t\t\tconst matchedToolCallIds = new Set<string>();\n\t\t\tfor (let i = index + 1; i < allMessages.length; i++) {\n\t\t\t\tconst nextMsg = allMessages[i];\n\n\t\t\t\t// Stop scanning when we hit another assistant message\n\t\t\t\tif (nextMsg.role === \"assistant\") {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Check tool result messages for matching IDs\n\t\t\t\tif (nextMsg.role === \"toolResult\") {\n\t\t\t\t\tmatchedToolCallIds.add(nextMsg.toolCallId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Filter out tool calls that don't have corresponding results\n\t\t\tconst filteredContent = assistantMsg.content.filter((block) => {\n\t\t\t\tif (block.type === \"toolCall\") {\n\t\t\t\t\treturn matchedToolCallIds.has(block.id);\n\t\t\t\t}\n\t\t\t\treturn true; // Keep all non-toolCall blocks\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\t...assistantMsg,\n\t\t\t\tcontent: filteredContent,\n\t\t\t};\n\t\t});\n}\n"]}