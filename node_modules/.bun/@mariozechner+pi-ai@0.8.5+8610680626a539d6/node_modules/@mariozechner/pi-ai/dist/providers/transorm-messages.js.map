{"version":3,"file":"transorm-messages.js","sourceRoot":"","sources":["../../src/providers/transorm-messages.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Api, AssistantMessage, Message, Model } from \"../types.js\";\n\nexport function transformMessages<TApi extends Api>(messages: Message[], model: Model<TApi>): Message[] {\n\treturn messages\n\t\t.map((msg) => {\n\t\t\t// User and toolResult messages pass through unchanged\n\t\t\tif (msg.role === \"user\" || msg.role === \"toolResult\") {\n\t\t\t\treturn msg;\n\t\t\t}\n\n\t\t\t// Assistant messages need transformation check\n\t\t\tif (msg.role === \"assistant\") {\n\t\t\t\tconst assistantMsg = msg as AssistantMessage;\n\n\t\t\t\t// If message is from the same provider and API, keep as is\n\t\t\t\tif (assistantMsg.provider === model.provider && assistantMsg.api === model.api) {\n\t\t\t\t\treturn msg;\n\t\t\t\t}\n\n\t\t\t\t// Transform message from different provider/model\n\t\t\t\tconst transformedContent = assistantMsg.content.map((block) => {\n\t\t\t\t\tif (block.type === \"thinking\") {\n\t\t\t\t\t\t// Convert thinking block to text block with <thinking> tags\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: \"text\" as const,\n\t\t\t\t\t\t\ttext: `<thinking>\\n${block.thinking}\\n</thinking>`,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\t// All other blocks (text, toolCall) pass through unchanged\n\t\t\t\t\treturn block;\n\t\t\t\t});\n\n\t\t\t\t// Return transformed assistant message\n\t\t\t\treturn {\n\t\t\t\t\t...assistantMsg,\n\t\t\t\t\tcontent: transformedContent,\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn msg;\n\t\t})\n\t\t.map((msg, index, allMessages) => {\n\t\t\t// Second pass: filter out tool calls without corresponding tool results\n\t\t\tif (msg.role !== \"assistant\") {\n\t\t\t\treturn msg;\n\t\t\t}\n\n\t\t\tconst assistantMsg = msg as AssistantMessage;\n\t\t\tconst isLastMessage = index === allMessages.length - 1;\n\n\t\t\t// If this is the last message, keep all tool calls (ongoing turn)\n\t\t\tif (isLastMessage) {\n\t\t\t\treturn msg;\n\t\t\t}\n\n\t\t\t// Extract tool call IDs from this message\n\t\t\tconst toolCallIds = assistantMsg.content\n\t\t\t\t.filter((block) => block.type === \"toolCall\")\n\t\t\t\t.map((block) => (block.type === \"toolCall\" ? block.id : \"\"));\n\n\t\t\t// If no tool calls, return as is\n\t\t\tif (toolCallIds.length === 0) {\n\t\t\t\treturn msg;\n\t\t\t}\n\n\t\t\t// Scan forward through subsequent messages to find matching tool results\n\t\t\tconst matchedToolCallIds = new Set<string>();\n\t\t\tfor (let i = index + 1; i < allMessages.length; i++) {\n\t\t\t\tconst nextMsg = allMessages[i];\n\n\t\t\t\t// Stop scanning when we hit another assistant message\n\t\t\t\tif (nextMsg.role === \"assistant\") {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Check tool result messages for matching IDs\n\t\t\t\tif (nextMsg.role === \"toolResult\") {\n\t\t\t\t\tmatchedToolCallIds.add(nextMsg.toolCallId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Filter out tool calls that don't have corresponding results\n\t\t\tconst filteredContent = assistantMsg.content.filter((block) => {\n\t\t\t\tif (block.type === \"toolCall\") {\n\t\t\t\t\treturn matchedToolCallIds.has(block.id);\n\t\t\t\t}\n\t\t\t\treturn true; // Keep all non-toolCall blocks\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\t...assistantMsg,\n\t\t\t\tcontent: filteredContent,\n\t\t\t};\n\t\t});\n}\n"]}