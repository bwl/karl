import type { Static, TSchema } from "@sinclair/typebox";
import type { AssistantMessage, AssistantMessageEvent, ImageContent, Message, Model, SimpleStreamOptions, TextContent, Tool, ToolResultMessage } from "../types.js";
export interface AgentToolResult<T> {
    content: (TextContent | ImageContent)[];
    details: T;
}
export interface AgentTool<TParameters extends TSchema = TSchema, TDetails = any> extends Tool<TParameters> {
    label: string;
    execute: (toolCallId: string, params: Static<TParameters>, signal?: AbortSignal) => Promise<AgentToolResult<TDetails>>;
}
export interface AgentContext {
    systemPrompt: string;
    messages: Message[];
    tools?: AgentTool<any>[];
}
export type AgentEvent = {
    type: "agent_start";
} | {
    type: "turn_start";
} | {
    type: "message_start";
    message: Message;
} | {
    type: "message_update";
    assistantMessageEvent: AssistantMessageEvent;
    message: AssistantMessage;
} | {
    type: "message_end";
    message: Message;
} | {
    type: "tool_execution_start";
    toolCallId: string;
    toolName: string;
    args: any;
} | {
    type: "tool_execution_end";
    toolCallId: string;
    toolName: string;
    result: AgentToolResult<any> | string;
    isError: boolean;
} | {
    type: "turn_end";
    message: AssistantMessage;
    toolResults: ToolResultMessage[];
} | {
    type: "agent_end";
    messages: AgentContext["messages"];
};
export interface QueuedMessage<TApp = Message> {
    original: TApp;
    llm?: Message;
}
export interface AgentLoopConfig extends SimpleStreamOptions {
    model: Model<any>;
    preprocessor?: (messages: AgentContext["messages"], abortSignal?: AbortSignal) => Promise<AgentContext["messages"]>;
    getQueuedMessages?: <T>() => Promise<QueuedMessage<T>[]>;
}
//# sourceMappingURL=types.d.ts.map