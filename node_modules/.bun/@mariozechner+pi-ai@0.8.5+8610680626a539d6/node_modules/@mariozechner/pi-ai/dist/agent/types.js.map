{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/agent/types.ts"],"names":[],"mappings":"","sourcesContent":["import type { Static, TSchema } from \"@sinclair/typebox\";\nimport type {\n\tAssistantMessage,\n\tAssistantMessageEvent,\n\tImageContent,\n\tMessage,\n\tModel,\n\tSimpleStreamOptions,\n\tTextContent,\n\tTool,\n\tToolResultMessage,\n} from \"../types.js\";\n\nexport interface AgentToolResult<T> {\n\t// Content blocks supporting text and images\n\tcontent: (TextContent | ImageContent)[];\n\t// Details to be displayed in a UI or logged\n\tdetails: T;\n}\n\n// AgentTool extends Tool but adds the execute function\nexport interface AgentTool<TParameters extends TSchema = TSchema, TDetails = any> extends Tool<TParameters> {\n\t// A human-readable label for the tool to be displayed in UI\n\tlabel: string;\n\texecute: (\n\t\ttoolCallId: string,\n\t\tparams: Static<TParameters>,\n\t\tsignal?: AbortSignal,\n\t) => Promise<AgentToolResult<TDetails>>;\n}\n\n// AgentContext is like Context but uses AgentTool\nexport interface AgentContext {\n\tsystemPrompt: string;\n\tmessages: Message[];\n\ttools?: AgentTool<any>[];\n}\n\n// Event types\nexport type AgentEvent =\n\t// Emitted when the agent starts. An agent can emit multiple turns\n\t| { type: \"agent_start\" }\n\t// Emitted when a turn starts. A turn can emit an optional user message (initial prompt), an assistant message (response) and multiple tool result messages\n\t| { type: \"turn_start\" }\n\t// Emitted when a user, assistant or tool result message starts\n\t| { type: \"message_start\"; message: Message }\n\t// Emitted when an asssitant messages is updated due to streaming\n\t| { type: \"message_update\"; assistantMessageEvent: AssistantMessageEvent; message: AssistantMessage }\n\t// Emitted when a user, assistant or tool result message is complete\n\t| { type: \"message_end\"; message: Message }\n\t// Emitted when a tool execution starts\n\t| { type: \"tool_execution_start\"; toolCallId: string; toolName: string; args: any }\n\t// Emitted when a tool execution completes\n\t| {\n\t\t\ttype: \"tool_execution_end\";\n\t\t\ttoolCallId: string;\n\t\t\ttoolName: string;\n\t\t\tresult: AgentToolResult<any> | string;\n\t\t\tisError: boolean;\n\t  }\n\t// Emitted when a full turn completes\n\t| { type: \"turn_end\"; message: AssistantMessage; toolResults: ToolResultMessage[] }\n\t// Emitted when the agent has completed all its turns. All messages from every turn are\n\t// contained in messages, which can be appended to the context\n\t| { type: \"agent_end\"; messages: AgentContext[\"messages\"] };\n\n// Queued message with optional LLM representation\nexport interface QueuedMessage<TApp = Message> {\n\toriginal: TApp; // Original message for UI events\n\tllm?: Message; // Optional transformed message for loop context (undefined if filtered)\n}\n\n// Configuration for agent loop execution\nexport interface AgentLoopConfig extends SimpleStreamOptions {\n\tmodel: Model<any>;\n\tpreprocessor?: (messages: AgentContext[\"messages\"], abortSignal?: AbortSignal) => Promise<AgentContext[\"messages\"]>;\n\tgetQueuedMessages?: <T>() => Promise<QueuedMessage<T>[]>;\n}\n"]}